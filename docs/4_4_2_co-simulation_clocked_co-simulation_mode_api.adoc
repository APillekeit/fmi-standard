==== FMI Application Programming Interface [[clocked-co-simulation-api]]
:INSTANTIATE: fmi3Instantiate()
:DOSTEP: fmi3DoStep()
:NEWDISCRETESTATES: fmi3NewDiscreteStates()
:SETCLOCK: fmi3SetClock()
:GETCLOCK: fmi3GetClock()
:SETINTERVALDECIMAL: fmi3SetIntervalDecimal()
:SETINTERVALFRACTION: fmi3SetIntervalFraction()
:GETINTERVALDECIMAL: fmi3GetIntervalDecimal()
:GETINTERVALFRACTION: fmi3GetIntervalFraction()
:ENTEREVENTMODE: fmi3EnterEventMode()
:ENTERSTEPMODE: fmi3EnterStepMode()
:INTERMEDIATEUPDATE: fmi3CallbackIntermediateUpdate()
:INTERMEDIATEUPDATEINFO: fmi3IntermediateUpdateInfo
:DOEARLYRETURN: fmi3DoEarlyReturn()

In this section, signaling and retrieving clock tick as well as interface for supporting clocks in FMI for co-simulation will be discussed.
If an FMU for co-simulation declares clocks and clocked variables in the _modelDescription.xml_ file, it supports clocks.
The co-simulation master should indicate the FMU that the master has recognized the clock capabilities of the FMU and supports the clock handling by setting the CoSimulation mode to `fmi3ModeHybridCoSimulation` in `{INSTANTIATE}`.
Note than , even if no clock is defined by an FMU in _modelDescription.xml_, the master is allowed to set the CoSimulation mode to `fmi3ModeHybridCoSimulation` to be able to do early return.

If an FMU provides clocks, but the co-simulation master does not support or does not want to support early-return or clocks, by setting CoSimulation mode to `fmi3ModeCoSimulation`, the activation of model partitions inside of the FMU has to be handled internally within `{DOSTEP}`. 

_[Please note: If aperiodic clocks are present in an FMU, but the master does not support clocks, this usually leads to simulation result errors for that FMU._
_Therefore it is required to issue a warning log message so that the current simulation setting will lead to simulation errors._
_In such a situation, it is recommended that the FMU tries to minimize this error by either provide and check the clock's activation state via corresponding `fmi3Boolean` inputs._
_That have to be defined in the modelDescription.xml if associated model partitions shall be activated based on external events or, alternatively, activate the associated model partitions based on FMU internal rules.]_


===== Transfer of Input / Output Values and Parameters [[clocked-co-simulation-api-transfer-of-input-output-and-parameters]]
If the co-simulation master supports clocks, all inferred clocks of the model should be handled and inferred clock events should be scheduled. 
If a clock ticks (triggered or inferred), the FMU invokes the `{INTERMEDIATEUPDATE}` callback and sets `{INTERMEDIATEUPDATEINFO}.clocksTicked` to `fmi3True`. 
Then the master must call `{DOEARLYRETURN}` to do an early return from `{DOSTEP}`.
then the master should push the relevant FMUs into Event Mode by calling `{ENTEREVENTMODE}`. 
Then `{SETCLOCK}` (and `{SETINTERVALDECIMAL}` or `{SETINTERVALFRACTION}` if necessary) should be invoked to indicate the enable ticked clocks. 
Once the clock event is handled, the FMU should be pushed into Step Mode by calling `{ENTERSTEPMODE}`. 
In Step Mode, the co-simulation master can call `{DOSTEP}` for the time interval from the current event time instant until the next inferred event instants. 
Each clock, that ticks outside of the FMU, is activated for an FMU based on its _clockReference_ and an associated `{SETCLOCK}`.
Please note that `{SETCLOCK}` can activate multiple clocks with each call.

Note that `{DOSTEP}` may not reach the next inferred event instant because an early return or a triggered clock may happen.
The master checks the occurrence of triggered clocks through the `{INTERMEDIATEUPDATE}` callback. 

The FMU must not call the `{INTERMEDIATEUPDATE}` callback function with a `{INTERMEDIATEUPDATEINFO}.intermediateUpdateTime` value that is smaller (or equal ??? #[TODO]) than the `{INTERMEDIATEUPDATEINFO}.intermediateUpdateTime` value given in a preceeding call of `{INTERMEDIATEUPDATE}` with `{INTERMEDIATEUPDATEINFO}.intermediateStepFinished` is `fmi3True`.
#[TODO]: Recheck if this is the correct position. (Issue #546 https://github.com/modelica/fmi-standard/issues/546#issuecomment-505755107)#

Once the FMU is pushed into Event Mode, the activation status of triggered clocks are checked by `{GETCLOCK}` function. 

The simulation master sets and gets clock variable values similar to the FMI for ModelExchange, as defined in <<fmi-api-setting-getting-clock-activation-state>>.


===== Computation [[clocked-co-simulation-api-computation]]

Similar to FMI for ModelExchange, in order to activate inferred or triggered clocks of an FMU, it is required to push the FMU into Event Mode by calling `{ENTEREVENTMODE}`.
If a triggered clock happens, i.e., if `{DOSTEP}` returns with `earlyReturn` = `fmi3True` and `{INTERMEDIATEUPDATEINFO}.eventOccurred` or `{INTERMEDIATEUPDATEINFO}.clocksTicked` is `fmi3True`, the FMU must be pushed into the Event Mode by calling  `{ENTEREVENTMODE}`;

In order to retrieve the state of triggered clocks, `{GETCLOCK}` and `{GETINTERVALDECIMAL}` or `{GETINTERVALFRACTION}` need to be called in the Event Mode.
If the `{DOSTEP}` return value is `fmi3OK` and `earlyReturn` = `fmi3False`, the calling of `{GETCLOCK}`, `{GETINTERVALDECIMAL}`, `{GETINTERVALFRACTION}`, `{NEWDISCRETESTATES}` is only meaningful after `{SETCLOCK}` in the case of super-dense time iterations are desired.

Similar to the ModelExchange case, the allowed call order is `{GETCLOCK}`, `{GETINTERVALDECIMAL}`, `{GETINTERVALFRACTION}`, `fmi3GetXXX()`, `fmi3SetXXX()`. 
If a function is not required, its call can be omitted.
If one of these functions returns a value different than `fmi3OK` then the co-simulation should be stopped.  

If `fmi3EventInfo.terminateSimulation` becomes `fmi3True` after calling `{NEWDISCRETESTATES}` then the co-simulation should be stopped. 
Once handling of the clock events finished, the master calls `{ENTERSTEPMODE}` for that FMU to push it into Step Mode.
Note that it is not allowed to call `{ENTEREVENTMODE}` or `{ENTERSTEPMODE}` if the master or the FMU does not support clocks.

If the FMU defines an internal clock relationship between an aperiodic inferred clock and triggered clocks, (i.e., a triggered clock triggers the model partition associated with an inferred clock) the FMU performs an early return at the time instant of the tick of the triggered clock in such a union, see section <<variants-of-clocks>>.

Usually the co-simulation master should be able to derive (but is not forced to do so) the correct communication point times for inferred clocks in advance and thus it should be able to set the proper `communicationStepSize` for `{DOSTEP}`. 
This might not be possible if the ticking of an aperiodic inferred clock for an FMU depends on the ticking of an aperiodic triggered clock of another FMU.

It is also possible that a triggered clock ticks as a function of an aperiodic inferred clock tick.
For example, a triggered clock may tick one second after the tick of an aperiodic inferred clock.


===== Retrieving Status Information from the Slave [[clocked-co-simulation-api-retrieving-status-information-from-slave]]

#[TODO]: @Masoud: Is this section relevant as retrieving status informations from the slaves is described in <<retrieving-status-from-slave>>. Should this section be removed?#


===== State Machine of Calling Sequence from Master to Slave [[clocked-co-simulation-api-state-machine-calling-sequence]]

The following state machine defines the supported calling sequences.

.Calling sequence of clocked co-simulation mode.
image::images/calling-sequence-hybrid-co-simulation.svg[width=80%, align="center"]
[#figure-hybrid-co-simulation-state-machine]
#[TODO]: There are no functions called `fmi3EnterReconfigurationMode()` and `fmi3ExitReconfigurationMode()` in fmi3Functions.h?#

 In comparison to the state machine in section <<state-machine-co-simulation>> the entry state after *Initialization Mode* is the *Event Mode* because ... #[TODO] @ Masoud: Reasons that this state machine differs from `fmi3ModeCoSimulation`#
Each state of the state machine corresponds to a certain phase of a simulation as follows:

instantiated::
#[TODO]: @ Masoud: Same as in section <<state-machine-co-simulation>>? To be removed?#

Configuration Mode::
#[TODO]: @ Masoud: Same as in section <<state-machine-co-simulation>>? To be removed?#

Initialization Mode::
#[TODO]: @ Masoud: Same as in section <<state-machine-co-simulation>>? To be removed?#

Event Mode::
#[TODO]: @ Masoud: To be filled#

Step Mode::
#[TODO]: @ Masoud: To be filled#

Reconfiguration Mode::
#[TODO]: @ Masoud: To be filled#

terminated::
#[TODO]: @ Masoud: Same as in section <<state-machine-co-simulation>>? To be removed?#


===== Pseudo-code Example [[clocked-co-simulation-api-pseudo-code-example]]

In the following example, the usage of the FMI functions is sketched in order to clarify the typical calling sequence of the functions in a simulation environment. 
The example is given in a mix of pseudo-code and `'C'`, in order to keep it small and understandable. 
See pseudocode:
[source, c]
----
include::examples/pseudo_code_co_simulation_clocked.txt[]
----
