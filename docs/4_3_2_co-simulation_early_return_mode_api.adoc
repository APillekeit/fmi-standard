==== FMI Application Programming Interface
:DOSTEP: fmi3DoStep()
:CBIU: fmi3CallbackIntermediateUpdate()
:DER:  fmi3DoEarlyReturn()
:STIUI: fmi3IntermediateUpdateInfo

The boolean capability flag `canHandleEarlyReturn` in the modelDescription XML file indicates whether the FMU supports the early-return feature.  
The default value of this capability flag is false.
Each time an internal discontinuity or an event happens inside an FMU with capability flag `canHandleEarlyReturn=true`, a triggered clock ticks and the callback function `{CBIU}` is invoked by the FMU then the associated structure `{STIUI}` is sent back to the co-simulation master.

===== Communication of event time and input/output values 

In order to stablish a way to communicate the input and output and, in particular, the event time from the FMU to the co-simulation master, the `{CBIU}` callback is used.
[source, c]
----
include::../headers/fmi3FunctionTypes.h[tag=IntermediateStepFinished]
----
This callback allows internal events associated to triggered clock ticks be signaled from an FMU to the co-simulation master. 
If `fmu3Type` is set to `fmi3CoSimulation` and the Co-simulation mode is set to `fmi3ModeHybridCoSimulation`, the `{CBIU}` callback must be defined in `fmi3CallbackFunctions` in `fmi3Instantiate()`.
In other cases a NULL pointer can be assigned to the `{CBIU}` callback, such as if the `fmu3Type` is set to  `fmi3ModelExchange`.

The `{STIUI}`  argument in the `{CBIU}` function is a structure which is used to signal triggered clock ticks and internal events to the master.
Whenever the FMU invokes the `{CBIU}` callback function, it fills the `{STIUI}` structure to pass information concerning the call to the co-simulation master.
The structure is defined as follows:

[source, C]
----
include::../headers/fmi3FunctionTypes.h[tag=IntermediateUpdateInfo]
----

* 	`intermediateTime` is the simulation time at which the discontinuity has occurred within the FMU.
`intermediateTime` is either the exact `earlyReturnTime` required by the master for the break or the closest time greater than the `earlyReturnTime` required by the master.
If this time is not exactly the required `earlyReturnTime`, the master can rollback the FMU to precisely reach this event time. `intermediateTime` is also the time of intermediate steps of the internal FMU solver.


The following `fmi3Boolean` variables define the reasons of the discontinuity. Several variables can be set by the FMU. Default value of variables is `fmi3False`.

*	when `eventOccurred` is `fmi3True`, it means that `fmi3NewDiscreteStates()` function shall be called for gathering `fmi3eventInfo` related information about events e.g. caused by ticking triggered clocks at `intermediateTime;`
If this flag is `fmi3True` the master must call `{DER}` to do an early return and handle the event. 

*	when `clocksTicked`  is `fmi3True`, it means that `fmi3GetClock()` function should be called for gathering all clock related information about ticking triggered clocks at `intermediateTime;`.
This variable is relevant only if the master supports handling the clocks. 
If this flag is `fmi3True` the master must call `{DER}` to do an early return and handle the clock event. 

*	when `intermediateVariableSetAllowed` is `fmi3True`, the FMU signals that intermediate output values can be collected by the co-simulation master.

*	when `intermediateVariableGetAllowed` is `fmi3True`, the FMU signals that intermediate input values can be set by the co-simulation master.

*   when `canDoEarlyReturn` is `fmi3True` the master can request the FMU to return early at the current `intermediateTime` time instant via calling `fmi3DoEarlyReturn()` within the callback function `{CBIU}`. If `canDoEarlyReturn` is `fmi3False` the FMU will not do the early return, regardless of the master request.
If one of `eventOccurred` or `clocksTicked`  flags is `fmi3True`, `canDoEarlyReturn` value is ignored.[TODO: or must be fmi3True] 

Note that only the first discontinuity event at a Newtonian time instant shall be signaled that way. But, there may be an event iteration at a Newtonian time instant and have super dense time instants.

Based on the information delivered in `{STIUI}`, additional information about the discontinuity at that time instant can be obtained from the `fmi3EventInfo` structure after calling  `fmi3NewDiscreteStates()`  and/or `fmi3GetClock()`.

===== Early-return requested by the co-simulation master
The co-simulation master can request the FMU to end the `{DOSTEP}` at a Newtonian time instant and do an early return by calling the  `fmi3DoEarlyReturn()` function inside the callback function `{CBIU}`.
The co-simulation master is only allowed to call this function, if the boolean variable `{STIUI}.canDoEarlyReturn` is `fmi3True`.
If the FMU is successful to do an early return, the return value of the `earlyReturn` argument in `{DOSTEP}` is `fmi3True`, otherwise `fmi3False`.

The function `{DOSTEP}` has the following input and output arguments: 

[source, c]
----
include::../headers/fmi3FunctionTypes.h[tag=DoStep]
----

If the FMU returns from `{DOSTEP}` with the `earlyReturn = fmi3True` the co-simulation master has to call `fmi3EnterEventMode()` for that FMU.
Please note that, the co-simulation master can also call `fmi3EnterEventMode()` at communication instants to handle inferred events, as will be discussed in following sections.

===== Handling a Successful Early-Return by the Master

Once an FMU conducts a successful early-return and returns from `{DOSTEP}` with `earlyReturn = fmi3True`, the master should handle the event and resume the co-simulation.
If an FMU provides the early-return capability, the master should indicate the FMU that the  early-return feature is also supported by the master.
The co-simulation master signals to the FMU that it supports and has recognized the early return co-simulation capabilities of the FMU by setting the CoSimulation mode to `fmi3ModeHybridCoSimulation` in the `fmi3Instantiate()` function.
If the master does not support the early-return, the FMU is expected to not set the event flag `{STIUI}.eventOccurred` and in this case the FMU is imperatively ending `{DOSTEP}` computation at the next predefined communication instant (i.e., _currentCommunicationPoint_+ _communicationStepSize_).

If the early-return is supported by both the FMU and the master, the co-simulation master is supposed to catch all events through the `fmi3NewDiscreteStates()` function and the `fmi3EventInfo` structure.
The FMU stops computation at the first encountered triggered event (if any) and the event time is provided through `{STIUI}.intermediateTime`.
If `{DOSTEP}` returns with `earlyReturn = fmi3True` and an event has happened, i.e., `{STIUI}.eventOccurred` is `fmi3True`, then an event handling has to be done by the co-simulation master.
In order to start event handling the co-simulation master has to call `fmi3EnterEventMode()` for that FMU to push the FMU into Event Mode.

If the early-return request of the co-simulation master is ignored by the FMU, then `{DOSTEP}` returns with `earlyReturn = fmi3False`.
In this case, if the master needs a resynchronization of FMUs at an event time, but the _currentCommunicationPoint_ has passed the event time, the master needs to roll-back the FMU and repeat the step with a suitable _communicationStepSize_ (if the FMU supports the rollback).

In Event Mode and only after `{DOSTEP}` returns with `earlyReturn = fmi3True` a `fmi3NewDiscreteStates()` call returns `fmi3EventInfo` structure as a return argument. 
Not all elements of `fmi3EventInfo` are relevant and only the following elements may be considered:

-	when _newDiscreteStatesNeeded_ is true it means that the master should stay in Event Mode and another call to `fmi3NewDiscreteStates()` is required.

-	when _nextEventTimeDefined_ is true it means that an event time is available and the value is given by the `nextEventTime` value. 
This is the case when the model can report in advance the accurate time of the next predictable time event.

-	when _terminateSimulation_ is true it means that the model wants to stop integration and the co-simulation master should call `fmi3Terminate()`.


The only possible return code for `fmi3NewDiscreteStates()` function in this case is `fmi3OK`.
//TODO: what about fmi3Error?


In Event Mode it is allowed to `fmi3getXXX()` variable values of the FMU after the call of `fmi3NewDiscreteStates()` and it is allowed to `fmi3setXXX()` variable values before calling `fmi3NewDiscreteStates()`.  
The FMU leaves Event Mode when the master calls `fmi3EnterStepMode()` for that FMU.

It is not allowed to call `fmi3EnterEventMode()` or `fmi3EnterStepMode()` for an FMU does not support early-return or clocks. 


//TODO: verify entry point for state machine as discussed in https://github.com/APillekeit/fmi-standard/issues/4



===== State Machine of Calling Sequence from Master to Slave


===== Pseudo-code Example

In the following example, the usage of the FMI functions is illustrated in order to clarify the typical calling sequence of the functions in a simulation environment.
The example is given in a mix of pseudo-code and `'C'`, in order to keep it small and understandable. 
See pseudocode:
[source, c]
----
include::examples/pseudo_code_co_simulation_early_return.txt[]
----
