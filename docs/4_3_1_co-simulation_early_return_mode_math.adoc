==== Mathematical Description
:DOSTEP: fmi3DoStep()
===== Basics

//=== Improving efficiency in multi-FMU environment when asynchronous mode is used

Once an FMU has prematurely stopped its current `{DOSTEP}`  computation due to an unpredictable internal event before the normal end of the `{DOSTEP}`, all other concurrently running FMUs are to be stopped as soon as possible in order to minimize the time needed for the Master to resynchronize all the FMUs at the same (event) time.

Especially on multi-node architectures, signiﬁcant co-simulation speedup improvment is hoped if the Master can avoid waiting till the end of the longest `{DOSTEP}` when lots of FMUs are integrating in a parallel way.

In this context based on parallel calculations, the following figure illustrates different possibilities to synchronize FMUs at the same event time.


.different possibilities to synchronize parallel FMUs at the same event time.
[caption="Figure 12: "]
image::images/earlyreturn.png[width=100%, align="center"]

{DOSTEP} routines run in a parallel way on different cores, so that each FMU starts integration from communication point latexmath:[t_{i}] to reach the next communication point latexmath:[t_{i+1}].
Assuming an unexpected internal event is detected at latexmath:[t^{'}_{i+1}< t_{i+1}] during FMU~1~ integration, the Master is immediately informed thanks to the new Early Return feature. 
So the Master would like now avoid others FMUs exceed this event time as it would resynchronise all of them at this time as a new intermediate communication point.
On the figure, ongoing FMU computations can be broken either immediately (refer to case 2 for FMU~3~) or at latexmath:[t^{'}_{i+1}] (refer to case 3 for FMU~4~). 
Only FMU~2~ and FMU~3~ will be rolled back to latexmath:[t^{'}_{i+1}] by the Master as FMU~1~ and FMU~4~ have already reached the new communication point latexmath:[t^{'}_{i+1}].

Then, global execution time of the simulation is reduced.


In order to stop the execution of ongoing `{DOSTEP}`, the Master invokes `fmi3DoEarlyReturn()` during (i.e. within) `fmi3IntermediateStepFinished()` callback function and provides an `earlyReturnTime`.

Prototyping for this function follows and return code is always `fmi3OK`. 

[source, c]
----
include::../headers/fmi3FunctionTypes.h[tag=DoEarlyReturn]
----

After reception of this function call, the FMU stops the integration either at `earlyReturnTime` (if `current-FMU-time {lt}= earlyReturnTime`) or immediately (if `current-FMU-time {gt} earlyReturnTime`). Afterwards, the FMU reaches the `stepComplete` state and can there signal the premature stop to the master by setting   `earlyReturn` variable to `fmi3True`.

From this structure:

*	`intermediateStepTime` is either the exact `earlyReturnTime` required by the Master for the break or the closest time greater than the `earlyReturnTime` required by the Master.
If this time is not exactly the required `earlyReturnTime`, the Master can rollback the FMU to precisely reach this event time;
	
	
Note if the bit `“step broken”` is alone set to 1, no `fmi3NewDiscreteStates()` function call is required by the Master for this discontinuity.
